# 3.6.16 Multipath Path Selection

本节描述用于负载均衡网络的路径选择算法。**建议**UET 端点对 RUD 和 RUDI 流量执行多路径负载均衡，但具体的实现方式留给实现方决定。

该协议依赖多路径转发，将流量中的数据包分发到多条网络路径上。除了单路径的ROD服务外，数据包分发通常采用逐包等价多路径（ECMP）方式，即利用网络头字段的哈希运算，将数据包分发到多条路径上。与单路径传输相比，这种方法能够实现更高的吞吐量和更短的流完成时间。

一些网络交换机可以自行执行数据包分散，而不是通过对头字段进行哈希运算来确定路径。如果使用了路径感知多路径分散（3.6.16.4节），建议不要对UET流量启用这种行为，因为这会妨碍UET获取有关哪些路径发生拥塞的清晰信号。

尽管尝试了均衡分配流量，但特定路径仍可能出现拥堵。哈希算法无法保证均匀地分发数据包。未被分散的其他流量的存在可能会影响某些路径上的可用带宽。此外，故障可能导致某条路径不可用。如果源端主动平衡流量，就可以提高吞吐量并减少流完成时间。

---

## 3.6.16.1 Path Entropy

当采用数据包喷洒（packet spraying）时，通过改变数据包头部中携带熵值（EV）的熵字段的值，将数据包分散到多条路径上（见3.6.10.1节）。交换机使用熵字段来确定每个数据包通过哪条等价多路径（ECMP）到达目的地。允许的三种操作模式如下：

- **单路径（Single path）**（仅ROD使用）。在 EV 更换之前，CCC中的所有数据包在一段时间内使用同一个 EV。
- **随机喷洒（Oblivious spraying）**：CCC的数据包通过改变EV值（通常至少有256个值）在多个路径上进行喷射，以实现流量在所有可能路径上的均匀分布。
- **路径感知喷洒（Path-aware spraying）**：CCC的数据包通过自适应地改变EV来避免拥塞路径，从而在许多路径上进行喷射，这基于目的地提供的关于哪些EV看到了拥塞的反馈。

---

## 3.6.16.2 Single-Path Entropy

PDC 启动时，可靠性模块会生成一个 `AllocateCCC()` 事件，其中 sprayed=FALSE。CCC 会为流量数据包选择一个熵值。为确保在路由未发生变化或数据包未丢失的情况下，数据包按顺序到达，该 CCC 一次只使用一个熵值。

如果观察到网络拥塞，并确定拥塞不是发生在通往目的地的最终链路上（无法通过重新路由避免），则 CCC 可以更改其使用的熵值。为尽量减少重新排序和任何潜在重传的影响，建议 CCC 要么在流量空闲时更改熵值；如果没有闲置期，也不要比每 t_reroute RTTs 更改一次熵值更频繁。

流量在空闲多长时间后才会改变熵值是一种配置选择。在没有数据包传输的情况下随时切换是安全的，但这种保守的选择并不一定能提高性能。建议将 t_reroute 的默认值设置为至少 10 个 RTT，并可对该值进行配置。

如果源和目的地之间存在一个以上的单路径 PDC，PDS 应请求为它们分配不同的 CCC。同一对 FEP 之间的不同 CCC 应协调分配不同的熵值，以减少 CCC 使用同一单一路径的频率。

> 信息文本：
使用不同但相互协调的 CCC 的目的是减少流冲突的影响。如果不同的 PDC 使用不同的 EV，那么一个PDC 上的流冲突就不太可能影响到另一个 PDC，同时也能缓解拥塞。

---

## 3.6.16.3 Oblivious Multipath Spraying

源会为 CCC 维护一个熵值空间，但不会保存有关哪些熵值比其他熵值拥塞程度低的信息。熵空间的典型大小为 256 个值，但也可使用其他大小的空间。数据源应按伪随机顺序使用熵空间中的熵值，目标是在发生重复之前使用所有熵值一次。为了减少多个源设备同步到哈希结果相似的路径序列的概率，每个源设备应定期独立地重新随机化伪随机序列。

源如何选择伪随机序列是由实现定义的。简单的模块化**计数器**虽然不是伪随机的，但足以满足协议互操作性的要求，因此是允许的，但它依赖于交换机 ECMP 哈希函数来提供伪随机负载平衡。这在许多部署中可能已经足够。如果是这样，计数器应随机初始化，以避免同步。

随机喷洒与数据包修剪相结合时最为有效。通过数据包修剪，在发生拥塞丢包时，源端会迅速收到来自目的端的 NACK，并在拥塞控制允许的情况下尽快重传数据包。重新传输的数据包很可能会选择不同的路径。使用一个 BDP 左右的相对较低的修剪阈值可以防止队列不必要地扩大，而且由于修剪后的数据包在拥塞瓶颈处占用的容量很小，并能在不同路径上引起快速重传，因此带有修剪功能的随机包喷洒可以很好地主动平衡网络负载。

我们不鼓励不修剪的随机喷洒，因为它的负载均衡效果不如路径感知的packet spray。不过，在没有数据包修剪的网络中，如果信源无法保持足够的每路径状态，它可能会选择使用随机包喷洒。

---

## 3.6.16.4 Path-aware Multipath Spraying

与 oblivious spraying 类似，源端仍维护一组 EV 供 CCC 使用，这些熵值以伪随机的顺序使用。这个空间的大小应根据需要自适应调整，确保每个使用的值在不超过两个往返时间（RTT）内可以被重新利用。这种方法旨在避免负载均衡系统因过时的路径拥塞信息而作出错误响应。

在 ACK/NACK 中，目的端返回接收数据包的 熵值 及 `pds.flags.m`（是否遇到拥塞，基于 IP ECN-CE 位）。

接收方可以使用其他形式的遥测已确认一条路径是否处于拥塞状态。

当接收到带有pds.flags.m标志的ACK或NACK数据包时，源节点应确保所指示的熵值在至少一个 RTT 内不被重复使用。例外情况是，如果 ACK 或 NACK 表明大多数路径已拥堵。在这种情况下，负载均衡信号已经饱和，跳过路径将不再有效。有 “多少比例的路径拥堵” 才能让目的端判定负载均衡信号饱和应该是一个配置选项。合理的默认值是 50% 的路径拥堵。这个值是一个权衡：在网络过度订阅或拥塞时，不应无谓地减少熵池；然而，在发生拥堵时，应尽可能长时间地保持负载均衡。

源如何选择避免重用路径取决于具体实现。例如，两种可能的方法是：

- **REPS方法**：如 ACK 的`pds.flags.m`字段未被标记拥塞，则从其中获得的熵可以用于发送数据包。这种 self-clocking 机制实际上是在‘链路上’存储了熵值。如果数据包丢失，不会被ACK，因此熵不会被重用；同样，如果数据包被 ACK，但`pds.flags.m`标志显示拥塞，则不会重用 EV。REPS 可以通过一个小的本地循环缓冲区（远小于支持的 EV 空间，例如 8 个单位）来缓存好的熵值。这些熵值在发送数据包时会被使用。如果发送的数据包需要一个 EV 但缓冲区为空，可以使用新的（随机的）EV。

- **STrack方法**：维护一个位图，其中每个位对应一个熵值。当反馈显示某个由熵值选择的路径已拥塞时，位图中对应的位会被置位。源设备以伪随机顺序在熵空间中旋转。当源设备为发送的数据包选择一个 EV 时，如果对应的位已被置位，它将跳过该 EV，清除该位，并尝试下一个 EV。为了确保反馈的时效性，活跃的熵值空间大小可以动态调整，以便在大约**两个RTT**内重复使用未拥塞的熵值。

也可结合两者或使用其他机制。路径感知喷洒允许更主动的流量均衡。

---

## 3.6.16.5 检测与处理路径故障

Congestion management sublayer (CMS) 主要面向使用基于数据包头中熵值（Entropy）哈希进行 ECMP 负载均衡的交换网络。在这类网络中，每个目的地地址与一个特定的熵值对应唯一一条路径。路径感知的多路径喷洒（path-aware multipath spraying）可以利用这种映射关系，结合 ECN 反馈和由于数据包裁剪（trimming）而生成的 NACK，实现超出交换机自身能力的负载均衡。

大多数此类网络将使用动态路由协议来确定某个目标地址的 ECMP 路径集合。当网络中发生故障时，预计动态路由最终会将故障路径从候选集中移除，从而使原本映射到故障路径的熵值重新映射到可用路径。此类动态重路由过程可能需要多个往返时延（RTT），而所有在故障路径上进行喷洒的 UET 连接在此期间都将遭遇数据包丢失。

UET-CC 负载均衡如何处理这种短暂故障属于实现决策。例如，如果 UET-CC 正在执行路径感知的负载均衡，且启用了数据包裁剪功能，则实际发生的数据包丢失应较为少见。在这种情况下，UET-CC 发送端可以选择在较长时间内避免重用导致超时或基于 SACK 推断丢失的熵值，从而为路由协议的重新收敛留出时间。然而，如果未启用裁剪，那么此类丢包推断可能更为频繁。因此实现时需要谨慎处理，以避免从使用集中移除过多的熵值。

某些网络可能使用静态的熵值到路径的映射，而不使用动态路由协议绕过故障。在这种网络中，UET-CC 的路径感知多路径喷洒可以主动绕开故障路径，即不再使用那些导致超时或基于 SACK 推断为丢包的熵值。在这类网络中，主动路径选择显得尤为重要，因为路由协议不会自动移除不可用路径。如何实现这一机制仍取决于具体实现。

当 UET-CC 端点未进行路径感知的多路径喷发时，网络不必维持熵值与路径之间的稳定映射。在这类网络中，交换机可能基于每个数据包进行本地负载均衡决策。此时，UET-CC 的负载均衡**不应**尝试禁用任何与丢包相关的熵值，因为熵值与失败路径之间并不存在稳定的对应关系。

---

## 3.6.16.6 多端口与多平面操作

UET 支持多端口网卡（NIC），而 CCC 可以将流量喷洒到同时被单个 Packet delivery context (PDC) 使用的多个端口。多端口使用方式有多种，并非所有方式都被本规范支持，以下列出了几种可能的选项：

1. 每个端口连接至不同的平面，使用相同的 Fabric endpoint (FEP) 地址。不提供跨平面路由功能。
2. 每个端口连接至不同的平面，使用不同的 FEP 地址。
3. 每个端口连接至同一个平面，使用相同的 FEP 地址。采用任播（anycast）路由将数据包发送至拥有相同 FEP 地址的某一个目的端口。
4. 每个端口连接至同一个平面，使用不同的 FEP 地址。

本规范支持选项 1 和 3。

在本规范中，CCC 不维护地址信息，因此对于具有不同地址的多个端口，不予以直接支持。

选项 2 不被 CCC 直接支持，但在 CCC 选择了熵值和端口后，具体实现可通过一个额外的目的地 IP 地址映射表将 FEP/端口映射到相应的 IP 地址。本规范不涵盖该用例。

选项 4 的负载均衡要求 CCC 同时选择熵值、端口和 FEP 地址的组合，并在同一对 FEP 之间的不同源端口和目的端口间进行负载均衡。本规范不涵盖该用例。

---

### 3.6.16.6.1 多个独立平面，所有端口共享一个 FEP 地址

此用例对应于上文列出的选项 1。UET RUD 的 PDC 可在一对配置为多平面拓扑结构的多端口 FEP 之间创建，每个平面在逻辑或物理上都是独立的，使得从 FEP A 上某个平面 P 的端口发送的数据包将被 FEP B 上相同平面 P 的端口接收。在这种情况下，每个 FEP 的所有端口共享一个 IP 地址。

在此配置中，CCC 可通过在一系列熵值（Entropy Value, EV）上喷发流量实现跨平面与平面内的负载均衡，每个 EV 映射到一个特定的出口端口，也就映射到一个特定平面。每个 PDC 的 EV 只在一个平面上使用。UET 的 ACK 和 NACK 包会指明数据包的 EV，因此可明确识别反馈指向的是哪条路径。

多端口操作通过 PDS 调度器与 CCC 之间的 `GetSendParams()` 接口实现：

```
GetSendParams(free_port_list) -> port, Entropy, Credit_Target
```


调用 `GetSendParams()` 时，调度器提供当前具备剩余发送容量的端口列表。该列表中**必须**至少包含一个可用端口。

CCC 将从 `free_port_list` 中选取一个关联的 EV，并利用 ECN 反馈进行负载均衡，避免拥塞路径，行为与单端口操作类似。

---

### 3.6.16.6.2 多端口、单平面，所有端口共享一个 IP 地址

此用例对应于上述选项 3。在此情况下，多端口网卡连接到同一个平面，且所有属于同一 FEP 的端口共享一个 IP 地址。通过任播（Anycast）路由，所有端口都可以成为用于路由数据包的 ECMP 集合的一部分。

此时 CCC 将选择出口端口（如果存在多个空闲端口），但入口端口由交换机根据数据包中的 EV 哈希确定。从 CCC 的角度来看，选项 3 的行为与选项 1 相同，CCC **必须**将选定的 EV 始终映射到唯一的出口端口，以确保 ACK 和 NACK 中的 EV 指向一条明确的路径。

---

### 3.6.16.6.3 多端口网卡上的单端口喷发

某些实现**可以**将 FEP 映射到多端口网卡上的一个端口。对于本规范，选项 2 和 4 应以这种方式处理。在此情形下，每个端口在应用层被视为一个独立的 FEP，由应用程序负责在 FEP（即端口）之间进行流量负载均衡。

此时，PDS 及其 CCC 并不知晓其他端口的存在；CCC **应当**将整个熵值空间映射至其管理的单个端口。`GetSendParams()` 的 `free_port_list` 中仅包含一个端口，因此 CCC 的端口选择操作无实际意义。

---

# 3.6.17 UET CC 的交换机配置

UET-CC 使用 ECN 同时作为负载均衡机制和驱动 NSCC 的拥塞信号。UET-CC 还可选地使用数据包裁剪（trimming）技术以实现随机负载均衡和提前丢包指示。因此，正确配置网络交换机对于 UET-CC 的性能至关重要。

`Plane_BDP` 被定义为源与目的地之间**最低带宽**路径的带宽-时延积（BDP），此处不包括排队延迟，并假设该路径穿越网络核心。

在大多数网络中，其计算公式为：

```
Plane_BDP = min(sender.linkspeed, receiver.linkspeed) * config_base_rtt
```


对于采用多轨拓扑结构的多端口网卡，`linkspeed` 通常指的是**单个端口**的速率，而非所有端口的总带宽。

> 注释：
> `Plane_BDP` 可能不同于 CCC 算法在多轨多端口网卡下所使用的 BDP 值。在这种场景下，CCC 所使用的 BDP 基于全部 spray 端口的总带宽，而 `Plane_BDP` 只考虑单个端口或单个轨道。对于单端口网卡，`Plane_BDP` 和 `BDP` 是相同的。

UET 支持在每个 UET PDC 上使用两类或三类流量类别（见 3.6.4.7）。三类流量分类如下：

- **低优先级（TC_low）**
  - 其队列设置称为 `queue_low`
- **中优先级（TC_med）**
  - 队列设置为 `queue_med`
- **高优先级（TC_high）**
  - 队列设置为 `queue_high`

当使用两类流量时，中优先级（TC_med）将不会使用。

启用**概率性 ECN 标记**时的推荐默认设置如下：

```
queue_low.min_thresh = 0.2 * Plane_BDP
queue_low.max_thresh = 0.8 * Plane_BDP
```

ECN 也可以通过**确定性标记阈值**来设置，推荐的确定性 ECN 阈值为：

```
0.5 * Plane_BDP
```

一般建议使用概率性标记方式。

应**禁用** `queue_med` 和 `queue_high` 的 ECN。

---

启用裁剪（trimming）功能时，推荐的默认设置为：

```
queue_low.trim_threshold = Plane_BDP
queue_med.drop_threshold = Plane_BDP
queue_high.drop_threshold = Plane_BDP
```


若使用 `DSCP_TRIMMABLE_RTX` 码点保护重传数据包，则这些包的 `queue_low.trim_threshold` 推荐值为：

```
1.5 * Plane_BDP
```
> **说明性文本**：这些队列阈值设置是基于迄今为止的模拟结果。较低的丢弃阈值可能导致额外的高优先级流量损失。可能需要对已部署的实现进行额外调整。


若未启用裁剪，UET 拥塞控制算法仍支持当前广泛部署的共享交换机缓冲架构。尽管该算法可适应由共享缓冲区引起的延迟变化，仍推荐限制尾部丢包阈值。给定队列的推荐丢包阈值应为：

```
至少 2 * Plane_BDP，至多 5 * Plane_BDP
```

部署时可以不使用严格优先级，而是将 `queue_med` 与 `queue_low` 设置为相同优先级，通过加权轮询（如 WRR）等调度算法实现公平带宽分配。在裁剪率较高时，可确保 `queue_med` 拥有更大带宽份额。推荐的默认配置是：

```
当与 queue_low 竞争时，queue_med 占用 75% 的总带宽
```
